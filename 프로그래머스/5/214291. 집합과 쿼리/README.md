# [level 5] 집합과 쿼리 - 214291 

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/214291) 

### 성능 요약

메모리: 236 MB, 시간: 9083.40 ms

### 구분

코딩테스트 연습 > 2023 현대모비스 알고리즘 경진대회 예선

### 채점결과

정확성: 100.0<br/>합계: 100.0 / 100.0

### 제출 일자

2024년 11월 23일 14:52:21

### 문제 설명

<p>정수 0 ~ <code>n-1</code>을 담고 있는 크기가 <code>n</code>인 1차원 정수 배열 <code>a</code>가 있습니다.<br>
배열의 각 원소마다 하나의 집합을 이루고 있습니다.</p>

<p>당신은 여기에 다음 쿼리들을 실행하려고 합니다.</p>

<ol>
<li>[1, <code>x</code>, <code>y</code>] 형태의 쿼리가 주어집니다. 

<ul>
<li><code>y</code>가 포함된 집합의 원소들을 모두 <code>x</code>가 포함된 집합으로 옮깁니다.</li>
<li><code>x</code>와 <code>y</code>가 같은 집합에 속해있다면 해당 쿼리는 실행하지 않습니다.</li>
</ul></li>
<li>[2, <code>x</code>, <code>y</code>] 형태의 쿼리가 주어집니다. 

<ul>
<li>새로운 집합을 생성합니다.</li>
<li><code>x</code>와 <code>y</code>가 포함된 집합에서 <code>x</code>와 같거나 늦게 집합으로 들어왔으면서 <code>y</code>와 같거나 빠르게 집합으로 들어온 원소들을 새로 생성한 집합으로 옮깁니다.</li>
<li>집합에 들어온 순서는 몇 번째 쿼리로 집합에 들어왔는지로 판별합니다. 같은 쿼리로 집합에 들어왔다면 같은 순서로 집합에 들어왔다는 것을 의미합니다.</li>
<li><code>x</code>와 <code>y</code>는 항상 같은 집합에 포함되어 있습니다.</li>
</ul></li>
<li>[3, <code>x</code>, <code>y</code>] 형태의 쿼리가 주어집니다. 

<ul>
<li><code>x</code>와 <code>y</code>가 같은 집합에 속해있다면 <code>"Yes"</code>를, 그렇지 않다면 <code>"No"</code>를 return 할 배열의 뒤에 추가합니다.</li>
</ul></li>
</ol>

<p>집합은 크기가 0이 되면 사라지며, 초기 집합들은 0번째 쿼리로 형성됩니다.</p>

<p><code>a</code>의 길이를 나타내는 정수 <code>n</code>, 쿼리들을 담은 2차원 정수 배열 <code>queries</code>가 매개변수로 주어집니다. 쿼리들을 순서대로 실행했을 때, 3번 쿼리의 결과를 순서대로 담아 return 하도록 solution 함수를 완성해주세요.</p>

<hr>

<h5>제한사항</h5>

<ul>
<li>1 ≤ <code>n</code> ≤ 500,000</li>
<li>1 ≤ <code>queries</code>의 길이 ≤ 500,000

<ul>
<li><code>queries[i]</code>는 <code>i+1</code>번째로 실행할 쿼리를 나타내며, [<code>q</code>, <code>x</code>, <code>y</code>] 형태의 1차원 정수 배열입니다.</li>
<li>1 ≤ <code>q</code> ≤ 3</li>
<li>0 ≤ <code>x</code>, <code>y</code> &lt; <code>n</code></li>
<li>2번 쿼리의 경우 <code>x</code>와 <code>y</code>는 항상 같은 집합에 속해 있습니다.</li>
<li>3번 쿼리는 1개 이상 주어집니다.</li>
</ul></li>
</ul>

<hr>

<h5>입출력 예</h5>
<table class="table">
        <thead><tr>
<th>n</th>
<th>queries</th>
<th>result</th>
</tr>
</thead>
        <tbody><tr>
<td>4</td>
<td>[[3, 2, 3], [1, 3, 2], [3, 2, 3], [1, 2, 0], [3, 0, 1], [2, 2, 0], [3, 2, 3], [3, 0, 2]]</td>
<td>["No", "Yes", "No", "No", "Yes"]</td>
</tr>
<tr>
<td>7</td>
<td>[[1, 0, 1], [1, 2, 3], [3, 1, 3], [1, 2, 0], [3, 1, 3], [1, 1, 5], [1, 5, 4], [3, 4, 5], [2, 2, 5], [3, 4, 5]]</td>
<td>["No", "Yes", "Yes", "No"]</td>
</tr>
</tbody>
      </table>
<h5>입출력 예 설명</h5>

<p><strong>입출력 예 #1</strong></p>

<p>초기 집합은 다음과 같습니다.<br>
[0], [1], [2], [3]</p>

<ol>
<li><code>[3, 2, 3]</code>쿼리를 실행했을 때 결과는 다음과 같습니다.

<ol>
<li>2와 3은 다른 집합에 들어있으므로 return 할 배열의 뒤에 <code>"No"</code>를 추가합니다.</li>
</ol></li>
<li><code>[1, 3, 2]</code>쿼리를 실행했을 때 결과는 다음과 같습니다.

<ol>
<li>2가 들어있는 [2]의 원소들을 모두 3이 들어있는 [3]으로 옮깁니다.</li>
<li>쿼리를 실행한 뒤의 집합은 [0], [1], [2, 3]이 있습니다.</li>
</ol></li>
<li><code>[3, 2, 3]</code>쿼리를 실행했을 때 결과는 다음과 같습니다.

<ol>
<li>2와 3은 같은 집합에 있으므로 return 할 배열의 뒤에 <code>"Yes"</code>를 추가합니다.</li>
</ol></li>
<li><code>[1, 2, 0]</code>쿼리를 실행했을 때의 결과는 다음과 같습니다.

<ol>
<li>0이 들어있는 [0]의 모든 원소들을 2가 들어있는 [2, 3]으로 옮깁니다.</li>
<li>쿼리를 실행한 뒤의 집합은 [0, 2, 3], [1]이 있습니다.</li>
</ol></li>
<li><code>[3, 0, 1]</code>쿼리를 실행했을 때의 결과는 다음과 같습니다.

<ol>
<li>0과 1은 다른 집합에 들어있으므로 return 할 배열의 뒤에 <code>"No"</code>를 추가합니다.</li>
</ol></li>
<li><code>[2, 2, 0]</code>쿼리를 실행했을 때의 결과는 다음과 같습니다.

<ol>
<li>2는 2번째 쿼리로 현재 집합에 들어왔고, 0은 4번째 쿼리로 현재 집합에 들어왔습니다.</li>
<li>2와 0이 속한 [0, 2, 3]에서 2~4번째 쿼리에 들어온 원소인 0과 2로 새로운 집합을 만듭니다.</li>
<li>쿼리를 실행한 뒤의 집합은 [0, 2], [1], [3]이 있습니다.</li>
</ol></li>
<li><code>[3, 2, 3]</code>쿼리를 실행했을 때의 결과는 다음과 같습니다.

<ol>
<li>2와 3은 다른 집합에 들어있으므로 return 할 배열의 뒤에 <code>"No"</code>를 추가합니다.</li>
</ol></li>
<li><code>[3, 0, 2]</code>쿼리를 실행했을 때의 결과는 다음과 같습니다.

<ol>
<li>0과 2는 같은 집합에 들어있으므로 return 할 배열의 뒤에 <code>"Yes"</code>를 추가합니다.</li>
</ol></li>
</ol>

<p>return 할 배열은 [<code>"No"</code>, <code>"Yes"</code>, <code>"No"</code>, <code>"No"</code>, <code>"Yes"</code>]입니다.</p>

<p><strong>입출력 예 #2</strong></p>

<p>초기 집합은 다음과 같습니다.<br>
[0], [1], [2], [3], [4], [5], [6]</p>

<p>쿼리를 실행하는 과정은 다음과 같습니다.</p>

<ol>
<li><code>[1, 0, 1]</code>쿼리를 실행했을 때 결과는 다음과 같습니다.

<ol>
<li>1이 들어있는 [1]의 원소들을 모두 0이 들어있는 [0]으로 옮깁니다.</li>
<li>쿼리를 실행한 뒤의 집합은 [0, 1], [2], [3], [4], [5], [6]이 있습니다.</li>
</ol></li>
<li><code>[1, 2, 3]</code>쿼리를 실행했을 때 결과는 다음과 같습니다.

<ol>
<li>3이 들어있는 [3]의 원소들을 모두 2가 들어있는 [2]로 옮깁니다.</li>
<li>쿼리를 실행한 뒤의 집합은 [0, 1], [2, 3], [4], [5], [6]이 있습니다.</li>
</ol></li>
<li><code>[3, 1, 3]</code>쿼리를 실행했을 때 결과는 다음과 같습니다.

<ol>
<li>1과 3은 다른 집합에 있으므로 return 할 배열의 뒤에 <code>"No"</code>를 추가합니다.</li>
</ol></li>
<li><code>[1, 2, 0]</code>쿼리를 실행했을 때 결과는 다음과 같습니다.

<ol>
<li>0이 들어있는 [0, 1]의 원소들을 모두 2가 들어있는 [2, 3]으로 옮깁니다.</li>
<li>쿼리를 실행한 뒤의 집합은 [0, 1, 2, 3], [4], [5], [6]이 있습니다.</li>
</ol></li>
<li><code>[3, 1, 3]</code>쿼리를 실행했을 때 결과는 다음과 같습니다.

<ol>
<li>1과 3은 같은 집합에 있으므로 return 할 배열의 뒤에 <code>"Yes"</code>를 추가합니다.</li>
</ol></li>
<li><code>[1, 1, 5]</code>쿼리를 실행했을 때 결과는 다음과 같습니다.

<ol>
<li>5가 들어있는 [5]의 원소들을 모두 1이 들어있는 [0, 1, 2, 3]으로 옮깁니다.</li>
<li>쿼리를 실행한 뒤의 집합은 [0, 1, 2, 3, 5], [4], [6]이 있습니다.</li>
</ol></li>
<li><code>[1, 5, 4]</code>쿼리를 실행했을 때 결과는 다음과 같습니다.

<ol>
<li>4가 들어있는 [4]의 원소들을 모두 5가 들어있는 [0, 1, 2, 3, 5]로 옮깁니다.</li>
<li>쿼리를 실행한 뒤의 집합은 [0, 1, 2, 3, 4, 5], [6]이 있습니다.</li>
</ol></li>
<li><code>[3, 4, 5]</code>쿼리를 실행했을 때 결과는 다음과 같습니다.

<ol>
<li>4와 5는 같은 집합에 있으므로 return 할 배열의 뒤에 <code>"Yes"</code>를 추가합니다.</li>
</ol></li>
<li><code>[2, 2, 5]</code>쿼리를 실행했을 때 결과는 다음과 같습니다.

<ol>
<li>2와 5가 들어있는 [0, 1, 2, 3, 4, 5] 집합에서 쿼리가 실행됩니다.</li>
<li>2는 0번째 쿼리로 집합에 들어왔고, 5는 6번째 쿼리로 집합에 들어왔습니다.</li>
<li>0~6번째 쿼리에 [0, 1, 2, 3, 4, 5] 집합에 들어온 원소는 0, 1, 2, 3, 5 입니다.</li>
<li>쿼리를 실행한 뒤의 집합은 [0, 1, 2, 3, 5], [4], [6]이 있습니다.</li>
</ol></li>
<li><code>[3, 4, 5]</code>쿼리를 실행했을 때 결과는 다음과 같습니다.

<ol>
<li>4와 5는 다른 집합에 있으므로 return 할 배열의 뒤에 <code>"No"</code>를 추가합니다.</li>
</ol></li>
</ol>

<p>return 할 배열은 [<code>"No"</code>, <code>"Yes"</code>, <code>"Yes"</code>, <code>"No"</code>]입니다.</p>


> 출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges