## 문제

섬으로 이루어진 나라가 있고, 모든 섬을 다리로 연결하려고 한다. 이 나라의 지도는 N×M 크기의 이차원 격자로 나타낼 수 있고, 격자의 각 칸은 땅이거나 바다이다.

섬은 연결된 땅이 상하좌우로 붙어있는 덩어리를 말하고, 아래 그림은 네 개의 섬으로 이루어진 나라이다. 색칠되어있는 칸은 땅이다.

![img](https://upload.acmicpc.net/38cb578e-b289-4b72-841e-422a1458d617/-/preview/)

다리는 바다에만 건설할 수 있고, 다리의 길이는 다리가 격자에서 차지하는 칸의 수이다. 다리를 연결해서 모든 섬을 연결하려고 한다. 섬 A에서 다리를 통해 섬 B로 갈 수 있을 때, 섬 A와 B를 연결되었다고 한다. 다리의 양 끝은 섬과 인접한 바다 위에 있어야 하고, 한 다리의 방향이 중간에 바뀌면 안된다. 또, 다리의 길이는 2 이상이어야 한다.

다리의 방향이 중간에 바뀌면 안되기 때문에, 다리의 방향은 가로 또는 세로가 될 수 밖에 없다. 방향이 가로인 다리는 다리의 양 끝이 가로 방향으로 섬과 인접해야 하고, 방향이 세로인 다리는 다리의 양 끝이 세로 방향으로 섬과 인접해야 한다.

섬 A와 B를 연결하는 다리가 중간에 섬 C와 인접한 바다를 지나가는 경우에 섬 C는 A, B와 연결되어있는 것이 아니다. 

아래 그림은 섬을 모두 연결하는 올바른 2가지 방법이고, 다리는 회색으로 색칠되어 있다. 섬은 정수, 다리는 알파벳 대문자로 구분했다.

| ![img](https://upload.acmicpc.net/41f71ecc-97b4-4351-b741-4b8336576246/-/preview/) | ![img](https://upload.acmicpc.net/3b158fdf-74ba-47d7-a224-9e5b753b8453/-/preview/) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 다리의 총 길이: 13D는 2와 4를 연결하는 다리이고, 3과는 연결되어 있지 않다. | 다리의 총 길이: 9 (최소)                                     |

다음은 올바르지 않은 3가지 방법이다

| ![img](https://upload.acmicpc.net/c7c663a1-4ebb-4c89-9a6a-4157513c1a30/-/preview/) | ![img](https://upload.acmicpc.net/390361f9-0647-4ff8-9709-7c1de26c0929/-/preview/) | ![img](https://upload.acmicpc.net/2a1d4415-0a0d-4508-8a14-1956fdf650ec/-/preview/) |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| C의 방향이 중간에 바뀌었다                                   | D의 길이가 1이다.                                            | 가로 다리인 A가 1과 가로로 연결되어 있지 않다.               |

다리가 교차하는 경우가 있을 수도 있다. 교차하는 다리의 길이를 계산할 때는 각 칸이 각 다리의 길이에 모두 포함되어야 한다. 아래는 다리가 교차하는 경우와 기타 다른 경우에 대한 2가지 예시이다.

| ![img](https://upload.acmicpc.net/b6f340e2-8248-4385-9a6a-546e7a2648e4/-/preview/) | ![img](https://upload.acmicpc.net/dd98ec33-6796-455d-a612-8db31a9806f0/-/preview/) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| A의 길이는 4이고, B의 길이도 4이다.총 다리의 총 길이: 4 + 4 + 2 = 10 | 다리 A: 2와 3을 연결 (길이 2)다리 B: 3과 4를 연결 (길이 3)다리 C: 2와 5를 연결 (길이 5)다리 D: 1과 2를 연결 (길이 2)총 길이: 12 |

나라의 정보가 주어졌을 때, 모든 섬을 연결하는 다리 길이의 최솟값을 구해보자.

## 입력

첫째 줄에 지도의 세로 크기 N과 가로 크기 M이 주어진다. 둘째 줄부터 N개의 줄에 지도의 정보가 주어진다. 각 줄은 M개의 수로 이루어져 있으며, 수는 0 또는 1이다. 0은 바다, 1은 땅을 의미한다.

## 출력

모든 섬을 연결하는 다리 길이의 최솟값을 출력한다. 모든 섬을 연결하는 것이 불가능하면 -1을 출력한다.

## 제한

- 1 ≤ N, M ≤ 10
- 3 ≤ N×M ≤ 100
- 2 ≤ 섬의 개수 ≤ 6

## 예제 입력 1 복사

```
7 8
0 0 0 0 0 0 1 1
1 1 0 0 0 0 1 1
1 1 0 0 0 0 0 0
1 1 0 0 0 1 1 0
0 0 0 0 0 1 1 0
0 0 0 0 0 0 0 0
1 1 1 1 1 1 1 1
```

## 예제 출력 1 복사

```
9
```

## 예제 입력 2 복사

```
7 8
0 0 0 1 1 0 0 0
0 0 0 1 1 0 0 0
1 1 0 0 0 0 1 1
1 1 0 0 0 0 1 1
1 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0
1 1 1 1 1 1 1 1
```

## 예제 출력 2 복사

```
10
```

## 예제 입력 3 복사

```
7 8
1 0 0 1 1 1 0 0
0 0 1 0 0 0 1 1
0 0 1 0 0 0 1 1
0 0 1 1 1 0 0 0
0 0 0 0 0 0 0 0
0 1 1 1 0 0 0 0
1 1 1 1 1 1 0 0
```

## 예제 출력 3 복사

```
9
```

## 예제 입력 4 복사

```
7 7
1 1 1 0 1 1 1
1 1 1 0 1 1 1
1 1 1 0 1 1 1
0 0 0 0 0 0 0
1 1 1 0 1 1 1
1 1 1 0 1 1 1
1 1 1 0 1 1 1
```

## 예제 출력 4 복사

```
-1
```

## 문제풀이
- 각 좌표가 어디 섬에 포함되는지 확인하기 위해 bfs를 통해 각 섬에 번호를 저장한다.
- 각 좌표에서 어떤 섬에 다리를 연결할 수 있는지 확인한다. 상,하,좌,우로 인접한 땅을 발견하고, 땅이 없거나, 본인이 포함된 섬이나, 다리의 길이가 1 이하라면 제외, 다른 섬에 있고 설치할 수 있는 다리의 길이가 2 이상이라면 간선에 포함시킨다.
- 크루스칼 알고리즘을 이용한 최소 스패닝 트리를 이용하여 최단거리를 확인한다. 만약 최소 스패닝 트리의 결과 섬의 개수보다 적은 개수의 간선이 연결되었다면 모든 섬이 연결된 게 아니므로 -1을 반환한다.

```python
import sys
input = sys.stdin.readline
from collections import deque
from itertools import permutations
import heapq
import math


def find_island(x,y, num):
    if visited[x][y]:
        return 0
    visited[x][y] = num
    dir = ((-1,0), (1,0), (0,-1), (0,1))
    queue = deque()
    queue.append((x,y))
    while queue:
        x, y = queue.popleft()
        for i in range(4):
            hx, hy = x + dir[i][0], y + dir[i][1]
            if hx < 0 or hy <0 or hx>=n or hy>=m:
                continue
            if visited[hx][hy]:
                continue
            if graph[hx][hy] == 0:
                continue
            visited[hx][hy] = num
            queue.append((hx,hy))
    return 1


def make_bridge(x,y, wei_graph, n, m):
    dir = ((-1,0), (1,0), (0,-1), (0,1))
    for i in range(4):
        hx, hy = x, y
        dist = 0
        while True:
            hx, hy = hx + dir[i][0], hy + dir[i][1]
            if (hx < 0 or hy <0 or hx>=n or hy>=m):
                break
            #확인하려는 곳에 섬이 있다면 정지
            if graph[hx][hy] == 1:
                #확인하려는 곳이 자신의 섬이 아니고 거리가 1 초과라면
                if visited[hx][hy] != visited[x][y] and dist > 1:
                    wei_graph.append((dist, visited[x][y],visited[hx][hy]))
                break
            dist += 1

def find(n):
    if parent[n] != n:
        parent[n] = find(parent[n])

    return parent[n]

def union(a, b):
    a = find(a)
    b = find(b)

    if a < b:
        parent[b] = a
    else:
        parent[a] = b


def kruskal(num):
    wei_graph.sort()
    weight = 0
    cnt = 0
    for w, a, b in wei_graph:
        if find(a) == find(b):
            continue
        union(a,b)
        weight += w
        cnt += 1
    return weight if cnt == num else -1



n, m = map(int, input().split())
graph = [list(map(int, input().split())) for _ in range(n)]
visited = [[0]*(m) for _ in range(n)]
wei_graph = []
dir = ((-1,0), (1,0), (0,-1), (0,1))

island_num = 1
for x in range(n):
    for y in range(m):
        if graph[x][y] == 0 or visited[x][y] != 0:
            continue
        island_num += find_island(x,y, island_num)

for x in range(n):
    for y in range(m):
        if graph[x][y] == 0:
            continue
        make_bridge(x,y,wei_graph, n,m)

parent = [i for i in range(island_num)]

answer = kruskal(island_num-2)
print(answer)
```
