## 문제

성진이는 한 도시의 시장인데 거지라서 전력난에 끙끙댄다. 그래서 모든 길마다 원래 켜져 있던 가로등 중 일부를 소등하기로 하였다. 길의 가로등을 켜 두면 하루에 길의 미터 수만큼 돈이 들어가는데, 일부를 소등하여 그만큼의 돈을 절약할 수 있다.

그러나 만약 어떤 두 집을 왕래할 때, 불이 켜져 있지 않은 길을 반드시 지나야 한다면 위험하다. 그래서 도시에 있는 모든 두 집 쌍에 대해, 불이 켜진 길만으로 서로를 왕래할 수 있어야 한다.

위 조건을 지키면서 절약할 수 있는 최대 액수를 구하시오.

## 입력

입력은 여러 개의 테스트 케이스로 구분되어 있다.

각 테스트 케이스의 첫째 줄에는 집의 수 m과 길의 수 n이 주어진다. (*1 ≤ m ≤ 200000*, *m-1 ≤ n ≤ 200000*)

이어서 n개의 줄에 각 길에 대한 정보 x, y, z가 주어지는데, 이는 x번 집과 y번 집 사이에 양방향 도로가 있으며 그 거리가 z미터라는 뜻이다. (*0 ≤ x, y < m*, *x ≠ y*)

도시는 항상 연결 그래프의 형태이고(즉, 어떤 두 집을 골라도 서로 왕래할 수 있는 경로가 있다), 도시상의 모든 길의 거리 합은 231미터보다 작다.

입력의 끝에서는 첫 줄에 0이 2개 주어진다.

## 출력

각 테스트 케이스마다 한 줄에 걸쳐 절약할 수 있는 최대 비용을 출력한다.

## 예제 입력 1 복사

```
7 11
0 1 7
0 3 5
1 2 8
1 3 9
1 4 7
2 4 5
3 4 15
3 5 6
4 5 8
4 6 9
5 6 11
0 0
```

## 예제 출력 1 복사

```
51
```



## 문제풀이


- 크루스칼 알고리즘을 이용한 최소 스패닝 트리를 통해 구한 최소 비용을 전체 전력에서 뺀 값이 정답이다.
- 테스트케이스가 여러개 입력받는 경우임을 잊으면 안된다.

```python
import sys
input = sys.stdin.readline
from collections import deque
from itertools import permutations
import heapq
import math


def find(n):
    if parent[n] != n:
        parent[n] = find(parent[n])

    return parent[n]

def union(a, b):
    a = find(a)
    b = find(b)

    if a < b:
        parent[b] = a
    else:
        parent[a] = b


def kruskal(t):
    wei_graph.sort()
    weight = t
    for w, a, b in wei_graph:
        if find(a) == find(b):
            continue
        union(a,b)
        weight -= w
    return weight


answer = []
while True:
    n, m = map(int, input().split())
    if(n == 0 and m == 0):
        break
    wei_graph = []
    parent = [i for i in range(n)]
    all_elec = 0

    for _ in range(m):
        x, y, z = map(int, input().split())
        wei_graph.append((z, x, y))
        all_elec += z

    answer.append(kruskal(all_elec))

print(*answer, sep="\n")
```
