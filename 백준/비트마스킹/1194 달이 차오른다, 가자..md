## 문제

지금 민식이가 계획한 여행은 달이 맨 처음 뜨기 시작할 때 부터, 준비했던 여행길이다. 하지만, 매번 달이 차오를 때마다 민식이는 어쩔 수 없는 현실의 벽 앞에서 다짐을 포기하고 말았다.

민식이는 매번 자신의 다짐을 말하려고 노력했지만, 말을 하면 아무도 못 알아들을 것만 같아서, 지레 겁먹고 벙어리가 되어버렸다. 결국 민식이는 모두 잠든 새벽 네시 반쯤 홀로 일어나, 창 밖에 떠있는 달을 보았다.

하루밖에 남지 않았다. 달은 내일이면 다 차오른다. 이번이 마지막기회다. 이걸 놓치면 영영 못간다.

영식이는 민식이가 오늘도 여태것처럼 그냥 잠 들어버려서 못 갈지도 모른다고 생각했다. 하지만 그러기엔 민식이의 눈에는 저기 뜬 달이 너무나 떨렸다.

민식이는 지금 미로 속에 있다. 미로는 직사각형 모양이고, 여행길을 떠나기 위해 미로를 탈출하려고 한다. 미로는 다음과 같이 구성되어져있다.

- 빈 칸: 언제나 이동할 수 있다. ('.')
- 벽: 절대 이동할 수 없다. ('#')
- 열쇠: 언제나 이동할 수 있다. 이 곳에 처음 들어가면 열쇠를 집는다. ('a', 'b', 'c', 'd', 'e', 'f')
- 문: 대응하는 열쇠가 있을 때만 이동할 수 있다. ('A', 'B', 'C', 'D', 'E', 'F')
- 민식이의 현재 위치: 빈 곳이고, 민식이가 현재 서 있는 곳이다. ('0')
- 출구: 달이 차오르기 때문에, 민식이가 가야하는 곳이다. 이 곳에 오면 미로를 탈출한다. ('1')

달이 차오르는 기회를 놓치지 않기 위해서, 미로를 탈출하려고 한다. 한 번의 움직임은 현재 위치에서 수평이나 수직으로 한 칸 이동하는 것이다.

민식이가 미로를 탈출하는데 걸리는 이동 횟수의 최솟값을 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 미로의 세로 크기 N과 가로 크기 M이 주어진다. (1 ≤ N, M ≤ 50) 둘째 줄부터 N개의 줄에 미로의 모양이 주어진다. 같은 타입의 열쇠가 여러 개 있을 수 있고, 문도 마찬가지이다. 그리고, 문에 대응하는 열쇠가 없을 수도 있다. '0'은 한 개, '1'은 적어도 한 개 있다. 열쇠는 여러 번 사용할 수 있다.

## 출력

첫째 줄에 민식이가 미로를 탈출하는데 드는 이동 횟수의 최솟값을 출력한다. 만약 민식이가 미로를 탈출 할 수 없으면, -1을 출력한다.

## 예제 입력 1 복사

```
1 7
f0.F..1
```

## 예제 출력 1 복사

```
7
```

## 예제 입력 2 복사

```
5 5
....1
#1###
.1.#0
....A
.1.#.
```

## 예제 출력 2 복사

```
-1
```

## 예제 입력 3 복사

```
7 8
a#c#eF.1
.#.#.#..
.#B#D###
0....F.1
C#E#A###
.#.#.#..
d#f#bF.1
```

## 예제 출력 3 복사

```
55
```

## 예제 입력 4 복사

```
3 4
1..0
###.
1...
```

## 예제 출력 4 복사

```
3
```

## 예제 입력 5 복사

```
3 5
..0..
.###.
..1.A
```

## 예제 출력 5 복사

```
6
```

## 예제 입력 6 복사

```
4 5
0....
.#B#A
.#.#.
b#a#1
```

## 예제 출력 6 복사

```
19
```

## 예제 입력 7 복사

```
1 11
c.0.C.C.C.1
```

## 예제 출력 7 복사

```
12
```

## 예제 입력 8 복사

```
3 6
###...
#0A.1a
###...
```

## 예제 출력 8 복사

```
-1
```

## 문제풀이
- 열쇠의 유무에 따라 길이 달라지는 BFS다.
- 열쇠는 존재 유무는 비트마스킹을 이용한다.
- a가 존재한다면 1, b가 존재한다면 10, c가 존재한다면 100... 각각의 키를 이진수로 저장하여 열쇠의 존재유무에 따라 최대 64개의 경우의 수가 발생한다.
- 열쇠를 가지고 있을 때와 열쇠를 갖고 있지 않을 때와의 길을 전혀 다르므로 visited를 3차원 배열로 생성하여 어떤 열쇠를 가지고 어떤 길을 갔었는지를 확인한다.
- 나아가야 할 길에 벽이 있거나, 같은 열쇠를 가지고 방문했거나, 문에 맞는 열쇠를 가지고 있지 않다면 큐에 추가하지 않는다.
- 만약 나아가야 할 길에 열쇠가 존재한다면 현재 열쇠값에 찾은 열쇠의 이진수 합집합을 하여 열쇠를 갱신해준다.
- 출구에 도착하면 도착하는데 걸린 시간을 반환한다.
- 만약 큐가 빌 때까지 출구를 찾지 못했다면 -1을 반환한다.


```python
import sys
from collections import deque

def bfs(start):
    dir = ((-1,0),(1,0),(0,-1),(0,1))
    Lock ={"A":1,"B":2 , "C":4,"D":8,"E":16,"F":32}
    Key = {"a":1,"b":2 , "c":4,"d":8,"e":16,"f":32}
    x, y = start
    visited[0][x][y] = True
    queue = deque()
    queue.append((0,x,y,0))

    while queue:
        key, x, y, time = queue.popleft()
        for i in range(4):
            next_key = key
            hx, hy = x + dir[i][0], y + dir[i][1]
            if hx<0 or hy <0 or hx >= n or hy >= m:
                continue
            if visited[key][hx][hy]:
                continue
            if graph[hx][hy] == "#":
                continue
            if graph[hx][hy] in Lock.keys():
                if key & Lock[graph[hx][hy]] == 0:
                    continue
            if graph[hx][hy] in Key.keys():
                next_key = key | Key[graph[hx][hy]]
            visited[next_key][hx][hy] = True
            queue.append((next_key, hx, hy, time+1))
            if graph[hx][hy] == "1":
                return time+1
    return -1


n, m = map(int, input().split())
graph = []
visited = [[[False]*(m) for _ in range(n)] for _ in range(1<<6)]
start = (0,0)
for i in range(n):
    arr = list(input().rstrip())
    graph.append(arr)
    for j in range(m):
        if arr[j] == "0":
            start = (i,j)



print(bfs(start))
```
