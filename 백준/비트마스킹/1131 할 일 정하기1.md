## 문제

N명의 사람과 N개의 일이 있다. 각 사람은 일을 하나 담당해야 하고, 각 일을 담당하는 사람은 한 명 이어야 한다. 또한, 모든 사람은 모든 일을 할 능력이 있다.

사람은 1번부터 N번까지 번호가 매겨져 있으며, 일도 1번부터 N번까지 번호가 매겨져 있다.

Dij를 i번 사람이 j번 일을 할 때 필요한 비용이라고 했을 때, 모든 일을 하는데 필요한 비용의 최솟값을 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 사람과 일의 수 N (1 ≤ N ≤ 20)이 주어진다. 둘째 줄부터 N개의 줄에는 D의 내용이 주어진다. 비용은 10,000보다 작거나 같은 자연수이다.

## 출력

모든 일을 하는데 필요한 비용의 최솟값을 출력한다.

## 예제 입력 1 복사

```
3
2 3 3
3 2 3
3 3 2
```

## 예제 출력 1 복사

```
6
```

## 문제풀이

1. n의 길이는 최대 20이다.
2. 최솟값을 구해야하는 완전탐색 문제이다.
3. 모든 사람이 n개의 일 중 하나를 선택하여야 하는 문제이므로 시간복잡도는 $2^20$ 이다.
4. dp의 길이는 각 경우의 수를 저장할 수 있는 길이다.
5. dp에는 모든 경우의 수의 최솟값이 저장되며, 비트마스크로 저장된다.
6. for문을 $2^n$ 만큼 시도하며, 현재 i란 작업을 하는 인원을 파악하는 비트마스크로 판단한다.
7. 현재 몇 명이 업무에 종사하고 있는지 확인하여 다음에 투입될 인원을 파악한다.
8. 현재 업무 내용 중 투입되지 않은 인원을 파악하고, 투입된 이후의 dp의 경우 현재 최솟값과 투입되기 전의 최솟값에 현재 인원이 j번째 업무를 하는 경우를 비교하여 최솟값을 갱신한다.
9. dp[2*n(모든 인원이 투입된 경우)]를 출력한다.
10. 

```python
import sys
input = sys.stdin.readline

def counting(x):
    answer = 0
    #몇 명이 일하는 중인지 확인
    while x:
        answer += (1 & x);
        x >>= 1
    return answer


n = int(input())
arr = [list(map(int, input().split())) for _ in range(n)]

dp = [1e10] *(1<<n)
dp[0] = 0

for i in range(1<<n):
    k = counting(i)
    for j in range(n):
        #i는 현재 일하는 중인 사람의 비트마스크
        #j는 몇 번째 업무인지 확인하기 위한 값
        #i에 j번째 사람이 존재하는 경우의 최솟값(dp[i | (1<<j)])을 구하기 위해서, 현재 값과 k번째 사람이 j번 업무를 할 때를 비교하여 삽입
        if not i & (1<<j):
            dp[i | (1<<j)] = min(dp[i | (1<<j)], dp[i] + arr[k][j])

print(dp[-1])
```

