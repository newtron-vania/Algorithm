## 문제
수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다.

## 입력
첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다.

둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (-1,000,000,000 ≤ Ai ≤ 1,000,000,000)

## 출력
첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.

둘째 줄에는 정답이 될 수 있는 가장 긴 증가하는 부분 수열을 출력한다.

## 예제 
```
입력 1 
6
10 20 10 30 20 50
출력 1 
4
10 20 30 50
```

## 해결방안

가장 긴 증가하는 부분 수열 4의 연장선이다.

https://www.acmicpc.net/problem/14002

이번엔 입력되는 원소의 최대 개수가 1000000개이기 때문에 시간복잡도가 $O(N^2)$인 DP로는 해결할 수 없다. 그렇기에 $O(logN)$인 이분탐색을 이용하여야 한다.
다만, 이분탐색을 이용하면 최장 수열의 길이는 구할 수 있지만 최장 수열의 정상적인 형태는 보장할 수 없다. 그렇기에 최장 수열에 원소가 교체 혹은 추가될 때마다 추가적인 tracking을 해줘야 한다.


최장 수열 vector에 원소가 추가 혹은 교체될 때마다 원소가 최장수열의 어디에 배치됬는지 index를 따로 저장해준다. 이를 check[]라 하겠다.
최장 수열을 탐색한 이후, vector의 최대 index를 이용하여 check를 뒤에서부터 최대 index와 같은 값을 검색하고, 제일 처음 검색된 곳의 index에 대치하는 수열 A의 원소로 최장 수열의 index에 존재하는 원소를 교체하고, 검색할 index를 1 감소시켜가며 검색을 실시한다.

1. check 배열 맨 뒤부터 보면 2이다. 아직 3이 나오지 않았으니 넘어간다.

|   0   |   1   |   2   |   1   |   0   |   3   | **2** |
| ----- | ----- | ----- | ----- | ----- | ----- | ----- |

2. check 배열에서 3이 최초로 발견되었다! 이 3이 저장될 때의 전체 수열에서의 값은 40이다. vector(또는 stack도 가능)에 40을 넣어준다.

|   0   |   1   |   2   |   1   |   0   | **3** |   2   |
| ----- | ----- | ----- | ----- | ----- | ----- | ----- |

3. check 배열에서 0이 발견되었다. 현재 찾고있는 건 2이다. 넘어간다.

|   0   |   1   |   2   |   1   | **0** |   3   |   2   |
| ----- | ----- | ----- | ----- | ----- | ----- | ----- |

4.마찬가지로 2가 아니기 때문에 넘어간다.

|   0   |   1   |   2   | **1** |   0   |   3   |   2   |
| ----- | ----- | ----- | ----- | ----- | ----- | ----- |


5. 마침내 2가 처음 나왔다. 이때의 수열은 30이다. vector에 30을 넣어준다.

|   0   |   1   | **2** |   1   |   0   |   3   |   2   |
| ----- | ----- | ----- | ----- | ----- | ----- | ----- |

6. 마침내 1이 처음 나왔다. 이때의 수열은 20이다. vector에 20을 넣어준다.

|   0   | **1** |   2   |   1   |   0   |   3   |   2   |
| ----- | ----- | ----- | ----- | ----- | ----- | ----- |

7. 마침내 0이 처음 나왔다. 이때의 수열은 10이다. vector에 10을 넣어준다.

| **0** |   1   |   2   |   1   |   0   |   3   |   2   |
| ----- | ----- | ----- | ----- | ----- | ----- | ----- |

8. 현재 vector에는 40 30 20 10 순으로 들어갔고 뒤에서부터 빼면서 출력한다.


```python
#이분 탐색
def binary_search(start, end, target, arr):
    result = 0
    while start <= end:
        mid = (start + end)//2
        if answer[mid] < target:
            start = mid+1
        else:
            end = mid-1
    return start

n = int(input())
arr = list(map(int, input().split()))
#최장 수열 저장
answer = [arr[0]]
#최장 수열에 존재했던 위치 인덱스 저장
num_index = [i for i in range(n)]

#t - 최장 수열에 참여된 인덱스를 저장
for i in range(1, n):
    if answer[-1] < arr[i]:
        answer.append(arr[i])
        t = len(answer)-1
    elif answer[0] > arr[i]:
        answer[0] = arr[i]
        t = 0
    else:
        #이분 탐색으로 원소가 교체될 인덱스 검색
        t = binary_search(0, len(answer)-1, arr[i], arr)
        answer[t] = arr[i]
    #각 원소의 최장 수열 인덱스 저장
    num_index[i] = t
#실제 최장 수열로 교체 실시
k = len(answer)-1
for i in range(n-1, -1, -1):
    if num_index[i] == k:
        answer[k] = arr[i]
        k -= 1
print(len(answer))
print(*answer)
```
