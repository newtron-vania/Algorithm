## 문제

문자열이 주어졌을 때, 이 문자열을 다른 문자열로 바꾸는 편집 스크립트를 작성하려고 한다. 편집 스크립트에서 사용할 수 있는 명령은 아래와 같이 총 네 가지가 있다.

- 추가 ('a'): 한 글자를 출력한다. 이 명령은 입력 문자열을 건드리지 않는다.
- 삭제 ('d'): 한 글자를 삭제한다. 이 명령은 입력 문자열에서 맨 앞 글자를 삭제하고, 아무것도 출력하지 않는다.
- 수정 ('m'): 한 글자를 수정한다. 즉, 입력 문자열에서 맨 앞 글자를 삭제하고, 바꾼 글자를 출력한다.
- 복사 ('c'): 한 글자를 복사한다. 입력에서 맨 앞 글자를 삭제하고, 삭제한 그 글자를 출력한다.

가장 짧은 편집 스크립트란, 추가, 삭제, 수정을 가장 적게 사용한 스크립트이다.

두 문자열이 주어졌을 때, 첫 번째 문자열을 두 번째 문자열로 바꾸는 가장 짧은 편집 스크립트를 작성하는 프로그램을 작성하시오. 

## 입력

두 문자열이 한 줄에 하나씩 주어진다. 각 문자열은 영문알파벳과 숫자로만 이루어져 있으며, 길이는 1보다 크거나 같고, 17000보다 작거나 같다.

## 출력

가장 짧은 편집 스크립트를 출력한다. 한 명령을 한 줄에 하나씩 출력하며, 문제의 괄호에 나와있는 (a, d, m, c)중 하나를 출력하고, 그 명령을 수행하는데 사용한 글자를 출력한다. (출력할 글자나 삭제할 글자)

가장 짧은 편집 스크립트가 여러 가지인 경우에는 아무거나 출력하면 된다.

## 예제 입력 1 복사

```
abcde
xabzdey
```

## 예제 출력 1 복사

```
a x
c a
c b
m z
c d
c e
a y
```


## 문제풀이
- 최소 편집 거리를 구하고 백트래킹을 통해 경로를 구한다.
- 다만, 시간 제한이 8초에 메모리 제한이 128mb이기 때문에 비트 집합을 통한 DP를 하여야 하는데, 아직까지 구현 방법을 찾지 못했다.
- 아래 예제는 dp를 제외하고 백트래킹의 형태를 구현한 것이다.

```python
import sys

input = sys.stdin.readline

word1 = input().strip()
word2 = input().strip()
n = len(word1)
m = len(word2)
dp = [[0]*(m+1) for _ in range(n+1)]
for j in range(1, m+1):
    dp[0][j] = dp[0][j-1] + 1

for i in range(1, n+1):
    dp[i][0] = dp[i-1][0]+1
    for j in range(1, m+1):
        if word1[i-1] == word2[j-1]:
            dp[i][j] = dp[i-1][j-1]
        else:
            # dp[i-1][j-1] : 수정
            # dp[i-1][j] : 삭제
            # dp[i][j-1] : 삽입
            dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1

i = n
j = m
answer = []
for k in dp:
    print(*k)
while  i != 0 or j != 0:
    num = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])
    if num == dp[i][j]:
        i -= 1
        j -= 1
        answer.append("c "+ word2[j])
    elif num == dp[i-1][j-1]:
        i -= 1
        j -= 1
        answer.append("m " + word2[j])
    elif num == dp[i-1][j]:
        i -= 1
        answer.append("d " + word1[i])
    elif num == dp[i][j-1]:
        j -= 1
        answer.append("a " + word2[j])

print(*answer[::-1], sep="\n")
```
